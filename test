// Spring test 1 (pendulum)
    /*m_particles.push_back(Particle(QVector3D(0, 0, 0), 10, 10, false, QColor(0, 255, 0))); // m1
    m_particles.push_back(Particle(QVector3D(200, -100, 0), 10, 100, true, QColor(255, 0, 255))); // m2
    m_particles.push_back(Particle(QVector3D(-200, -100, 0), 10, 100, true, QColor(255, 0, 255))); // m3

    m_physicsSystem.AddRigidbody(&m_particles[0]);
    m_physicsSystem.AddRigidbody(&m_particles[1]);
    m_physicsSystem.AddRigidbody(&m_particles[2]);

    Spring spring1(15000.0f, 1.0f, 0.0f, QColor(255, 0, 0));
    spring1.SetParticles(&m_particles[0], &m_particles[1]);
    m_physicsSystem.AddSpring(spring1);

    Spring spring2(15000.0f, 1.0f, 0.0f, QColor(255, 0, 0));
    spring2.SetParticles(&m_particles[0], &m_particles[2]);
    m_physicsSystem.AddSpring(spring2);

    m_physicsSystem.ChangeFrictionParticle(1.0f);*/

    // Spring test 2 (double pendulum)
    /*m_particles.push_back(Particle(QVector3D(0, 0, 0), 10, 20, false));
    m_particles.push_back(Particle(QVector3D(-200, -200, -100), 10, 200, true));
    m_particles.push_back(Particle(QVector3D(0, -100, -100), 10, 20, true));

    m_physicsSystem.AddRigidbody(&m_particles[0]);
    m_physicsSystem.AddRigidbody(&m_particles[1]);
    m_physicsSystem.AddRigidbody(&m_particles[2]);

    Spring spring1(150000.0f, 1.0f, 0.0f);
    spring1.SetParticles(&m_particles[0], &m_particles[1]);
    
    Spring spring2(15000.0f, 1.0f, 0.0f);
    spring2.SetParticles(&m_particles[1], &m_particles[2]);

    m_physicsSystem.AddSpring(spring1);
    m_physicsSystem.AddSpring(spring2);

    m_physicsSystem.ChangeFrictionParticle(1.0f);*/

    // Spring test 3 (collision)
    /*m_particles.push_back(Particle(QVector3D(-0.5, 0, 0), 5, 10.0, false));
    m_particles.push_back(Particle(QVector3D(0.5, 0, 0), 5, 10.0, false));
    m_particles.push_back(Particle(QVector3D(-2, 0, 0), 10, 10.0, true, QColor(255, 0, 0)));
    m_particles.push_back(Particle(QVector3D(2, 0, 0), 10, 10.0, true, QColor(0, 0, 255)));

    m_physicsSystem.AddRigidbody(&m_particles[0]);
    m_physicsSystem.AddRigidbody(&m_particles[1]);
    m_physicsSystem.AddRigidbody(&m_particles[2]);
    m_physicsSystem.AddRigidbody(&m_particles[3]);

    // add constraints (collision particles between red and blue particules)
    m_physicsSystem.AddConstraint(&m_particles[2]);
    m_physicsSystem.AddConstraint(&m_particles[3]);

    m_physicsSystem.ChangeFriction(1.0f);

    Spring spring1(10000.0f, 1.0f, 0.0f);
    spring1.SetParticles(&m_particles[0], &m_particles[2]);

    Spring spring2(10000.0f, 1.0f, 0.0f);
    spring2.SetParticles(&m_particles[1], &m_particles[3]);

    m_physicsSystem.AddSpring(spring1);
    m_physicsSystem.AddSpring(spring2);*/

    // Spring test 4 (rope)
    /*int n = 30;
    float l = 20;

    m_particles.push_back(Particle(QVector3D(0, 0, 0), 2, 10.0, false));

    for (int i = 1; i < n; ++i) {
        m_particles.push_back(Particle(QVector3D(i*l+l, 0, 0), 2, 10.0, true));
    }
    for (int i = 1; i < n; ++i) {
        Spring spring(15000.0f, 0.0f, 0.0f);
        spring.SetParticles(&m_particles[i], &m_particles[i - 1]);
        m_physicsSystem.AddSpring(spring);
    }

    for (long unsigned int i = 0; i < m_particles.size(); i++) {
        m_physicsSystem.AddRigidbody(&m_particles[i]);
        m_physicsSystem.AddConstraint(&m_particles[i]);
    }*/

    // Spring test 5 (breast)
    /*int n = 15;
    float r = 1;
    float e = 0.2;
    int s1 = 110;
    int s2 = 70;
    int boule = 17;
    float bouleG = 30.0f;

    float k1a = 450;
    float k1b = 900;
    float k1c = 900;

    float k2a = 450 * 5;
    float k2b = 900 * 5; 
    float k2c = 900 * 5;


    float t0 = M_PI / (n - 1);
    float n1 = static_cast<int>(0.5 + (s1 * M_PI / 180) / t0);
    float n2 = static_cast<int>(0.5 + (s2 * M_PI / 180) / t0);

    float l1 = 2 * r * sin(t0 / 2);
    float l2 = e;
    float l3 = 2 * (r + e) * sin(t0 / 2);

    // qDebug() << l1 << " " << l2 << " " << l3;

    l1 = 0;
    l2 = 0;
    l3 = 0;

    // qDebug() << l1 << " " << l2 << " " << l3;

    // Set up the particles
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, r, 0), 5, 10.0, false, QColor(255, 0, 106)));

    for (int i = 1; i < n1; ++i) {
        float t = i * t0;
        float x = r * sin(t);
        float y = r * cos(t);
        m_particles.push_back(std::make_shared<Particle>(QVector3D(x, y, 0), 5, 10.0, true, QColor(255, 0, 0)));

    }
    for (int i = n1; i < n1+n2; ++i) {
        float t = i * t0;
        float x = r * sin(t);
        float y = r * cos(t);
        m_particles.push_back(std::make_shared<Particle>(QVector3D(x, y, 0), 5, 10.0, true, QColor(0, 0, 255)));
        
    }

    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, -r, 0), 5, 10.0, false, QColor(255, 0, 106)));
    int m2 = m_particles.size() - 1;
    
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, r+e, 0), 5, 10.0, false, QColor(255, 0, 106)));
    int m3 = m_particles.size() - 1;

    for (int i = 1; i < n1; ++i) {
        float t = i * t0;
        float x = (r + e) * sin(t);
        float y = (r + e) * cos(t);
        m_particles.push_back(std::make_shared<Particle>(QVector3D(x, y, 0), 5, 10.0, true, QColor(255, 0, 0)));
    }
    for (int i = n1; i < n1 + n2; ++i) {
        float t = i * t0;
        float x = (r + e) * sin(t);
        float y = (r + e) * cos(t);
        m_particles.push_back(std::make_shared<Particle>(QVector3D(x, y, 0), 5, 10.0, true, QColor(0, 0, 255)));
    }

    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, -r-e, 0), 5, 10.0, false, QColor(255, 0, 106)));
    int m4 = m_particles.size() - 1;

    float a = 0;
    while (a < r) {
        m_particles.push_back(std::make_shared<Particle>(QVector3D(0, a, 0), 5, 10.0, false, QColor(255, 0, 106)));
        a = a + e / 2;
    }

    float b = -e / 2;
    while (b > -r) {
        m_particles.push_back(std::make_shared<Particle>(QVector3D(0, b, 0), 5, 10.0, false, QColor(255, 0, 106)));
        b = b - e / 2;
    }

    // Set up the springs
    for(int i = 1; i < n1; ++i) {
        Spring spring(k1a, 1.0f, l1, QColor(255, 0, 0));
        spring.SetParticles(m_particles[i].get(), m_particles[i-1].get());
        m_springs.push_back(std::make_shared<Spring>(spring));
    }
    for(int i = n1; i < n1+n2; ++i) {
        Spring spring(k2a, 1.0f, l1, QColor(0, 0, 255));
        spring.SetParticles(m_particles[i].get(), m_particles[i-1].get());
        m_springs.push_back(std::make_shared<Spring>(spring));
    }
    Spring spring1(k2a, 1.0f, l1, QColor(0, 0, 255));
    spring1.SetParticles(m_particles[m2].get(), m_particles[n1+n2-1].get());
    m_springs.push_back(std::make_shared<Spring>(spring1));

    for (int i = 1; i < n1; ++i) {
        Spring spring1(k1c, 1.0f, l3, QColor(255, 0, 0));
        spring1.SetParticles(m_particles[i + n].get(), m_particles[i + n - 1].get());
        m_springs.push_back(std::make_shared<Spring>(spring1));
        Spring spring2(k1b, 1.0f, l2, QColor(255, 0, 0));
        spring2.SetParticles(m_particles[i + n].get(), m_particles[i].get());
        m_springs.push_back(std::make_shared<Spring>(spring2));
        // Spring spring3(k1c, 1.0f, l3, QColor(255, 0, 0));
        // spring3.SetParticles(m_particles[i + n].get(), m_particles[i + 1].get());
        // m_springs.push_back(std::make_shared<Spring>(spring3));
        // Spring spring4(k1b, 1.0f, l2, QColor(255, 0, 0));
        // spring4.SetParticles(m_particles[i + n + 1].get(), m_particles[i].get())
        // m_springs.push_back(std::make_shared<Spring>(spring4));
    }
    // Spring s8(k1c, 1.0f, l3, QColor(255, 0, 0));
    // s8.SetParticles(m_particles[0].get(), m_particles[n+1].get());
    // m_springs.push_back(std::make_shared<Spring>(s8));
    // Spring s9(k1a, 1.0f, l1, QColor(255, 0, 0));
    // s9.SetParticles(m_particles[1].get(), m_particles[n].get());
    // m_springs.push_back(std::make_shared<Spring>(s9));
    for (int i = n1; i < n1 + n2; ++i) {
        Spring spring1(k2c, 1.0f, l3, QColor(0, 0, 255));
        spring1.SetParticles(m_particles[i + n].get(), m_particles[i + n - 1].get());
        m_springs.push_back(std::make_shared<Spring>(spring1));
        Spring spring2(k2b, 0.0f, l2, QColor(0, 0, 255));
        spring2.SetParticles(m_particles[i + n].get(), m_particles[i].get());
        m_springs.push_back(std::make_shared<Spring>(spring2));
        // Spring spring3(k2c, 1.0f, l3, QColor(0, 0, 255));
        // spring3.SetParticles(m_particles[i + n].get(), m_particles[i + 1].get());
        // m_springs.push_back(std::make_shared<Spring>(spring3));
        // Spring spring4(k2b, 1.0f, l2, QColor(0, 0, 255));
        // spring4.SetParticles(m_particles[i + n + 1].get(), m_particles[i].get())
        // m_springs.push_back(std::make_shared<Spring>(spring4));
    }
    Spring spring2(k2c, 1.0f, l3, QColor(0, 0, 255));
    spring2.SetParticles(m_particles[m4].get(), m_particles[2*(n1+n2)].get());
    m_springs.push_back(std::make_shared<Spring>(spring2));

    Spring spring3(0, 1.0f, 2*r+2*e, QColor(255, 0, 106));
    spring3.SetParticles(m_particles[m3].get(), m_particles[m4].get());
    m_springs.push_back(std::make_shared<Spring>(spring3));

    // Set up particles in
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0.30, 0, 0), boule, bouleG, true, QColor(255, 0, 106)));
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0.30, -0.30, 0), boule, bouleG, true, QColor(255, 0, 106)));
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0.30, 0.30, 0), boule, bouleG, true, QColor(255, 0, 106)));
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0.70, 0, 0), boule, bouleG, true, QColor(255, 0, 106)));
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0.70, -0.30, 0), boule, bouleG, true, QColor(255, 0, 106)));
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0.70, 0.30, 0), boule, bouleG, true, QColor(255, 0, 106)));
    */

    /*
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, 0, 0), 30, 20, true, QColor(255, 255, 255))); // Base
    m_particles.push_back(std::make_shared<Particle>(QVector3D(1, 0, 0), 30, 10, false, QColor(255, 0, 0))); // x
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, 1, 0), 30, 10, false, QColor(0, 0, 255))); // y
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, 0, 1), 30, 10, false, QColor(0, 255, 0))); // z


    Spring spring1(1.0f, 0.5f, 0.0f);
    spring1.SetParticles(m_particles[0].get(), m_particles[1].get());
    m_springs.push_back(std::make_shared<Spring>(spring1));

    Spring spring2(1.0f, 0.5f, 0.0f);
    spring2.SetParticles(m_particles[0].get(), m_particles[2].get());
    m_springs.push_back(std::make_shared<Spring>(spring2));

    Spring spring3(1.0f, 0.5f, 0.0f);
    spring3.SetParticles(m_particles[0].get(), m_particles[3].get());
    m_springs.push_back(std::make_shared<Spring>(spring3));

    // Scene particles-ground
    m_particles.push_back(std::make_shared<Particle>(QVector3D(0, 2, 0), 30, 10, true, QColor(255, 0, 255))); // Ground
    */

    // Test load model
    /*Model* model = new Model("./resources/models/cube.obj");
    // m_physicsSystem.AddRigidbody(model);

    ConvertModelToParticleSprings(model, m_particles, m_springs);

    for (long unsigned int i = 0; i < m_particles.size(); i++) {
        m_physicsSystem.AddRigidbody(std::move(m_particles[i]));
        m_physicsSystem.AddConstraint(m_particles[i].get());
    }

    for (long unsigned int i = 0; i < m_springs.size(); i++) {
        m_physicsSystem.AddSpring(*m_springs[i]);
    }*/

    // auto model = std::make_shared<Model>("./resources/models/suzanne.obj");
    // model->color = QColor(255, 255, 255);
    // m_physicsSystem.AddRigidbody(model);


    // void PhysicsSystem::Update(float deltaTime)
    // {
    //     const int substeps = 3; // Substeps for the simulation
    //     float subDelta = deltaTime / float(substeps);
    
    //     for (int step = 0; step < substeps; ++step) {
    
    //         // Apply gravity to rigidbodies
    //         for (auto& body : bodies) {
    //             body->ApplyForces(); // gravity * mass
    //         }
    
    //         // Apply forces to springs
    //         for (auto& spring : springs) {
    //             spring->ApplyForce(subDelta);
    //         }
    
    //         // Update rigidbodies
    //         for (auto& body : bodies) {
    //             body->Update(subDelta);
    //         }
    
    //         // Update BVH for collision detection
    //         bvhRigidbodies = BuildBVH(constraints);
    //         bvhTriangleColliders = BuildBVH(triangleColliders);
    
    //         // // Resolve collisions
    //         const int constraintIterations = 4;
    //         for (int iter = 0; iter < constraintIterations; ++iter) {
    //             for (auto& constraint : constraints) {
    //                 std::vector<std::shared_ptr<Rigidbody>> nearbyRigdibodies;
    //                 std::vector<std::shared_ptr<TriangleCollider>> nearbyTriangles;
    
    //                 QueryBVH<Rigidbody>(constraint->GetAABB(), bvhRigidbodies.get(), nearbyRigdibodies);
    //                 constraint->SolveConstraints(nearbyRigdibodies);
    
    //                 QueryBVH<TriangleCollider>(constraint->GetAABB(), bvhTriangleColliders.get(), nearbyTriangles);
    //                 constraint->SolveConstraints(nearbyTriangles);
    //             }
    //         }
    //     }
    
    // }

// void PhysicsSystem::Update(float deltaTime)
// {
//     // Apply forces on the object
//     for (size_t i = 0, size = bodies.size(); i < size; ++i) {
//         bodies[i]->ApplyForces();
//         bodies[i]->Update(deltaTime);
//     }

//     // Apply spring forces
//     for (size_t i = 0, size = springs.size(); i < size; ++i) {
//         for (int step = 0, substeps = 5; step < substeps; ++step) {
//             springs[i]->ApplyForce(deltaTime / substeps);
//         }
//         // springs[i]->ApplyForce(deltaTime);
//     }

//     // Update BVH for collision detection
//     bvhRigidbodies = BuildBVH(constraints);
//     bvhTriangleColliders = BuildBVH(triangleColliders);

//     // Solve constraints
//     const int constraintIterations = 5;
//     for (int iter = 0; iter < constraintIterations; ++iter) {
//         for (auto& constraint : constraints) {
//             std::vector<std::shared_ptr<Rigidbody>> nearbyRigdibodies;
//             std::vector<std::shared_ptr<TriangleCollider>> nearbyTriangles;

//             QueryBVH<Rigidbody>(constraint->GetAABB(), bvhRigidbodies.get(), nearbyRigdibodies);
//             constraint->SolveConstraints(nearbyRigdibodies);

//             QueryBVH<TriangleCollider>(constraint->GetAABB(), bvhTriangleColliders.get(), nearbyTriangles);
//             constraint->SolveConstraints(nearbyTriangles);
//         }
        
//     }
// }


/*void Rigidbody::SolveSphereSphereCollision(SphereCollider& s1, SphereCollider& s2, Rigidbody* rb)
{
    QVector3D delta = s1.position - s2.position;
    float dist = delta.length();
    float minDist = s1.radius + s2.radius;

    if (dist < minDist && dist > 1e-6f) { // Collision 
        QVector3D normal = delta.normalized();
        float penetration = minDist - dist;

        QVector3D relativeVelocity = GetVelocity() - rb->GetVelocity();
        float velocityAlongNormal = QVector3D::dotProduct(relativeVelocity, normal);

        if (velocityAlongNormal > 0) return; // Avoid double collision

        float restitution = fminf(cor, rb->cor);
        float invMassA = InvMass();
        float invMassB = rb->InvMass();

        float impulseMagnitude = -(1.0f + restitution) * velocityAlongNormal / (invMassA + invMassB);
        QVector3D impulse = normal * impulseMagnitude;

        if (isMovable) AddLinearImpulse(impulse * invMassA);
        if (rb->isMovable) rb->AddLinearImpulse(-impulse * invMassB);

        // Position correction
        float totalInvMass = invMassA + invMassB;
        if (totalInvMass > 0.0f) {
            QVector3D correction = normal * penetration * 0.5f; // Apply progressively
            float ratioA = invMassA / totalInvMass;
            float ratioB = invMassB / totalInvMass;
            
            if (isMovable) transform.position += correction * ratioA;
            if (rb->isMovable) rb->transform.position -= correction * ratioB;
        }
    }
}*/

/*void Rigidbody::SolveSphereOBBCollision(SphereCollider& sphere, OBB& box, Rigidbody* rb)
{
    // Convert sphere position to box local space
    QVector3D localSpherePos = QMatrix4x4(box.orientation.transposed()).map(sphere.position - box.position);
    
    // Clamp local sphere position to box half-extents
    QVector3D closestPoint = localSpherePos;
    closestPoint.setX(qBound(-box.size.x(), closestPoint.x(), box.size.x()));
    closestPoint.setY(qBound(-box.size.y(), closestPoint.y(), box.size.y()));
    closestPoint.setZ(qBound(-box.size.z(), closestPoint.z(), box.size.z()));
    
    // Convert back to world space
    QVector3D worldClosestPoint = box.position + QMatrix4x4(box.orientation).map(closestPoint);
    QVector3D delta = sphere.position - worldClosestPoint;
    float dist = delta.length();
    
    if (dist < sphere.radius && dist > 1e-6f) { // Collision detected
        QVector3D normal = delta.normalized();
        float penetration = sphere.radius - dist;
        
        QVector3D relativeVelocity = GetVelocity() - rb->GetVelocity();
        float velocityAlongNormal = QVector3D::dotProduct(relativeVelocity, normal);
        
        if (velocityAlongNormal > 0) return; // Avoid double collision
        
        float restitution = fminf(cor, rb->cor);
        float invMassA = InvMass();
        float invMassB = rb->InvMass();
        
        float impulseMagnitude = -(1.0f + restitution) * velocityAlongNormal / (invMassA + invMassB);
        QVector3D impulse = normal * impulseMagnitude;
        
        if (isMovable) AddLinearImpulse(impulse);
        if (rb->isMovable) rb->AddLinearImpulse(-impulse);
        // if (isMovable) AddLinearImpulse(impulse * invMassA);
        // if (rb->isMovable) rb->AddLinearImpulse(-impulse * invMassB);

        // Position correction
        float totalInvMass = invMassA + invMassB;
        if (totalInvMass > 0.0f) {
            QVector3D correction = normal * penetration * 0.5f; // Apply progressively
            float ratioA = invMassA / totalInvMass;
            float ratioB = invMassB / totalInvMass;
            
            if (isMovable) transform.position += correction * ratioA;
            if (rb->isMovable) rb->transform.position -= correction * ratioB;

        }
    }

}*/


// QVector3D A = m_profilePoints[i] - centerCurve;
//             QVector3D B = ringPoints[i] - centerCurve;

//             A.normalize();
//             B.normalize();

//             // Slerp entre deux directions
//             float theta = std::acos(QVector3D::dotProduct(A, B));
//             float sinTheta = std::sin(theta);

//             QVector3D dir;
//             if (sinTheta > 0.0001f) {
//                 dir = (std::sin((1 - t) * theta) * A + std::sin(t * theta) * B) / sinTheta;
//             } else {
//                 dir = A; // fallback si angle tr√®s petit
//             }

//             // Interpolation de la distance (si needed)
//             float radiusA = (m_profilePoints[i] - centerCurve).length();
//             float radiusB = (ringPoints[i] - centerCurve).length();
//             float r = (1 - t) * radiusA + t * radiusB;

//             QVector3D pos = centerCurve + dir * r;



/*void OpenGLWidget::CurveToParticlesSprings()
{
    if (!m_isCurve || !m_torsoModel) return;

    makeCurrent();
    // Clear previous model
    m_particles.clear();
    m_springs.clear();
    m_triangleColliders.clear();
    m_fillTriangleColliders.clear();

    // Parameters
    float mass = 1.0f;
    int numLayers = m_curveLayers + 2;
    float height = m_curveDepth;
    float layerStep = m_curveDepth / (numLayers - 1);
    float ringRadius = m_curveRingRadius;
    float thickness = 0.03f; 

    // Model curve
    m_profilePoints = m_curve.Sample(m_numSamples);

    // Remove the last points to avoid duplicates
    m_profilePoints.pop_back();

    size_t numPoints = m_profilePoints.size();
    if (numPoints < 3) return; // Not enough profilePoints to create a curve

    // Place sample points in the torso model
    for (size_t i = 0; i < numPoints; ++i) 
    {
        QVector3D p = GetPointOntoMesh(m_profilePoints[i]);
        m_profilePoints[i] = p;
    }

    // Compute the center of the curve
    QVector3D centerCurve(0, 0, 0);
    QVector3D centerRing(0, 0, 0);
    for (const auto& pt : m_profilePoints) centerCurve += pt;
    centerCurve /= static_cast<float>(numPoints);
    
    centerRing = centerCurve;

    // Compute the normal of the curve
    for (size_t i = 0; i < numPoints; ++i)
    {
        auto& p1 = m_profilePoints[i];
        auto& p2 = m_profilePoints[(i + 1) % numPoints];
        auto& p3 = m_profilePoints[(i + 2) % numPoints];

        QVector3D v1 = p2 - p1;
        QVector3D v2 = p3 - p2;

        m_curveNormal += QVector3D::crossProduct(v1, v2).normalized();
    }
    m_curveNormal.normalize();

    // Add offset to the center
    centerRing.setY(centerRing.y() - 0.2f);
    // Set the center to he height
    // centerRing += m_curveNormal * height;
    
    QVector3D zAxis = m_curveNormal;
    QVector3D xAxis;

    if (std::abs(zAxis.y()) < 0.99f) xAxis = QVector3D::crossProduct(zAxis, QVector3D(0, 1, 0)).normalized();
    else xAxis = QVector3D::crossProduct(zAxis, QVector3D(1, 0, 0)).normalized();

    QVector3D yAxis = QVector3D::crossProduct(zAxis, xAxis).normalized();

    // Ring curve
    std::vector<QVector3D> ringPoints;
    for (size_t i = 0; i < numPoints; ++i)
    {
        float angle = static_cast<float>(i) / static_cast<float>(numPoints) * 2.0f * M_PI - M_PI_4;

        float cosAngle = std::cos(angle);
        float sinAngle = std::sin(angle);
        QVector3D p = cosAngle * xAxis * ringRadius + sinAngle * yAxis * ringRadius;

        ringPoints.push_back(centerRing + p);
    }

    // Add a closed triangle 
    std::vector<std::shared_ptr<TriangleCollider>> closingTriangles;

    for (size_t i = 0; i < numPoints; ++i) {
        const QVector3D& a = m_profilePoints[i];
        const QVector3D& b = m_profilePoints[(i + 1) % numPoints]; // wrap around

        // Triangle (a, b, center)
        auto tri = std::make_shared<TriangleCollider>(a, b, centerCurve);
        closingTriangles.push_back(tri);
    }

    m_fillTriangleColliders.insert(m_fillTriangleColliders.end(), closingTriangles.begin(), closingTriangles.end());

    // Create the layers of particles
    std::vector<std::vector<std::shared_ptr<Particle>>> layers;

    // Create the vector of stiffness for the springs
    std::vector<float> springStiffness(numPoints, 0.0f), 
        springCrossStiffness(numPoints, 0.0f),
        springThicknessStiffness(numPoints, 0.0f);

    for (int layer = 0; layer < numLayers; ++layer)
    {
        std::vector<std::shared_ptr<Particle>> layerParticles;

        float t = static_cast<float>(layer) / static_cast<float>(numLayers - 1);
        float tCurve = 1.0f + std::sin(-(1.0f - t) * M_PI_2); 
        float z = layer * layerStep;

        for (size_t i = 0; i < numPoints; ++i) {
            QVector3D pos = (1.0f - tCurve) * m_profilePoints[i] + tCurve * ringPoints[i];
            // QVector3D pos = (1.0f - tCurve) * ringPoints[i] + tCurve * m_profilePoints[i];
            // pos.setZ(m_profilePoints[i].z() + z); 

            // float length = (m_profilePoints[i] - ringPoints[i]).length();
            // float step = length / (numLayers - 1);
            // float z = layer * step;

            pos.setZ(pos.z() + z);


            auto p = std::make_shared<Particle>(pos, 1, mass, (layer != 0));
            p->AddFlag(PARTICLE_NO_COLLISION_WITH_US); p->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);
            layerParticles.push_back(p);
            m_particles.push_back(p);

            // Horizontally connect particles in the same layer
            if (i > 0) 
            {
                auto& p1 = layerParticles[i - 1];
                auto& p2 = layerParticles[i];
                if (layer == 0) springStiffness[i - 1] = GetStiffnessByQuadrant(p1->GetPosition(), p2->GetPosition(), centerCurve);
                float stiffness = springStiffness[i - 1];
                auto spring = std::make_shared<Spring>(p1, p2, (layer == numLayers - 1) ? 1000.0f : stiffness);
                m_springs.push_back(spring);
            }
        }

        // Close the curve
        auto& p1 = layerParticles.front();
        auto& p2 = layerParticles.back();
        if (layer == 0) springStiffness[numPoints - 1] = GetStiffnessByQuadrant(p1->GetPosition(), p2->GetPosition(), centerCurve);
        float stiffness = springStiffness[numPoints - 1];
        auto springLoop = std::make_shared<Spring>(p1, p2, (layer == numLayers - 1) ? 1000.0f : stiffness);
        m_springs.push_back(springLoop);

        layers.push_back(layerParticles);
    }

    // Vertical and diagonal connections between layers
    for (int layer = 0; layer < numLayers - 1; ++layer) {
        for (size_t i = 0; i < numPoints; ++i) {

            // edge
            auto& p1 = layers[layer][i];
            auto& p2 = layers[layer + 1][i];
            if (layer == 0) springStiffness[i] = GetStiffnessByQuadrant(p1->GetPosition(), p2->GetPosition(), centerCurve);
            float stiffness = springStiffness[i];
            auto spring = std::make_shared<Spring>(p1, p2, stiffness);
            m_springs.push_back(spring);

            // diagonal
            if (i > 0 && m_crossSpringModel) 
            {
                auto& p3 = layers[layer][i];
                auto& p4 = layers[layer + 1][i - 1];
                if (layer == 0) springCrossStiffness[i - 1] = GetStiffnessByQuadrant(p3->GetPosition(), p4->GetPosition(), centerCurve);
                float stiffness = springCrossStiffness[i - 1];
                auto s1 = std::make_shared<Spring>(p3, p4, stiffness);
                m_springs.push_back(s1);
                
                auto& p5 = layers[layer][i - 1];
                auto& p6 = layers[layer + 1][i];
                if (layer == 0) springCrossStiffness[i - 1] = GetStiffnessByQuadrant(p5->GetPosition(), p6->GetPosition(), centerCurve);
                stiffness = springCrossStiffness[i - 1];
                auto s2 = std::make_shared<Spring>(p5, p6, stiffness);
                m_springs.push_back(s2);
            }
        }
        // close the curve
        if (m_crossSpringModel)
        {
            auto& p1 = layers[layer].back();
            auto& p2 = layers[layer + 1].front();
            float stiffness = springStiffness[numPoints - 1];
            auto s1 = std::make_shared<Spring>(p1, p2, stiffness);
            m_springs.push_back(s1);

            auto& p3 = layers[layer].front();
            auto& p4 = layers[layer + 1].back();
            stiffness = springStiffness[numPoints - 1];
            auto s2 = std::make_shared<Spring>(p3, p4, stiffness);
            m_springs.push_back(s2);
        }
        
    }

    centerRing.setZ(centerRing.z() + height);

    // Center particle
    auto centerParticle = std::make_shared<Particle>(centerRing, 1, mass);
    centerParticle->SetFlags(PARTICLE_NO_COLLISION_WITH_US);
    m_particles.push_back(centerParticle);

    // Connect the center to the first layer
    for (auto& p : layers.back()) {
        auto spring = std::make_shared<Spring>(p, centerParticle, 1000.0f); 
        m_springs.push_back(spring);
    }
    auto ringlayers = layers.back();
    for (size_t i = 0; i < ringlayers.size(); ++i) { // Add springs for more rigidity
        auto& p1 = ringlayers[i];
        for (size_t j = 0; j < ringlayers.size(); ++j) {
            if (i == j) continue;
            auto& p2 = ringlayers[j];
            auto spring = std::make_shared<Spring>(p1, p2, 1000.0f);
            m_springs.push_back(spring);
        }
    }

    // Triangle collider generation
    for (int layer = 0; layer < numLayers - 1; ++layer)
    {
        const auto& current = layers[layer];
        const auto& next = layers[layer + 1];
        size_t count = current.size();

        for (size_t i = 0; i < count; ++i)
        {
            size_t next_i = (i + 1) % count;

            // First triangle of the quad
            auto a = current[i];
            a->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);
            auto b = next[i];
            b->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);
            auto c = next[next_i];
            c->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);

            // Second triangle of the quad
            auto d = current[next_i];

            m_triangleColliders.push_back(std::make_shared<TriangleCollider>(a, b, c));
            m_triangleColliders.push_back(std::make_shared<TriangleCollider>(a, c, d));
        }
    }

    for (size_t i = 0; i < ringlayers.size(); ++i)
    {
        size_t next_i = (i + 1) % ringlayers.size();

        auto a = ringlayers[i];
        a->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);
        auto b = ringlayers[next_i];
        b->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);
        auto c = centerParticle;
        c->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);

        m_triangleColliders.push_back(std::make_shared<TriangleCollider>(a, b, c));
    }

    m_fillTriangleColliders.insert(m_fillTriangleColliders.end(), m_triangleColliders.begin(), m_triangleColliders.end());

    // Thickness
    if (m_haveThickness) {
        std::vector<std::vector<std::shared_ptr<Particle>>> layersThickness;
        for (int layer = 0; layer < numLayers; ++layer)
        {
            std::vector<std::shared_ptr<Particle>> layerParticlesThickness;
            for (size_t i = 0; i < numPoints; ++i)
            {
                auto p = layers[layer][i];
                QVector3D normal = (p->GetPosition() - QVector3D(centerRing.x(), centerRing.y(), centerRing.z() * 0.5f)).normalized();
                QVector3D offsetPos = p->GetPosition() + normal * thickness;
                
                auto pt = std::make_shared<Particle>(offsetPos, 1, p->GetMass(), p->IsDynamic());
                pt->SetFlags(PARTICLE_NO_COLLISION_WITH_US); p->AddFlag(PARTICLE_ATTACHED_TO_TRIANGLE);
                layerParticlesThickness.push_back(pt);
                m_particles.push_back(pt);

                // Connect the new particle to the original one
                if (layer == 0) springStiffness[i] = GetStiffnessByQuadrant(p->GetPosition(), pt->GetPosition(), centerCurve);
                float stiffness = springStiffness[i];
                auto spring = std::make_shared<Spring>(p, pt, stiffness);
                m_springs.push_back(spring);

                if (i > 0) {
                    auto& p1 = layerParticlesThickness[i - 1];
                    auto& p2 = layerParticlesThickness[i];
                    if (layer == 0) springThicknessStiffness[i - 1] = GetStiffnessByQuadrant(p1->GetPosition(), p2->GetPosition(), centerCurve);
                    float stiffness = springThicknessStiffness[i - 1];
                    auto spring = std::make_shared<Spring>(p1, p2, stiffness);
                    m_springs.push_back(spring);
                }
            }

            // Close the curve
            auto& p1 = layerParticlesThickness.front();
            auto& p2 = layerParticlesThickness.back();
            if (layer == 0) springStiffness[numPoints - 1] = GetStiffnessByQuadrant(p1->GetPosition(), p2->GetPosition(), centerCurve);
            float stiffness = springStiffness[numPoints - 1];
            auto springLoop = std::make_shared<Spring>(p1, p2, stiffness);
            m_springs.push_back(springLoop);

            layersThickness.push_back(layerParticlesThickness);
        }

        // Vertical and diagonal connections between layers
        for (int layer = 0; layer < numLayers - 1; ++layer) {
            for (size_t i = 0; i < numPoints; ++i) {
                // edge
                auto& p1 = layersThickness[layer][i];
                auto& p2 = layersThickness[layer + 1][i];
                float stiffness = springStiffness[i];
                auto spring = std::make_shared<Spring>(p1, p2, (layer == numLayers - 1) ? 1000.0f : stiffness);
                m_springs.push_back(spring);

                // diagonal
                if (i > 0 && m_crossSpringModel) 
                {
                    auto& p3 = layersThickness[layer][i];
                    auto& p4 = layersThickness[layer + 1][i - 1];
                    float stiffness = springCrossStiffness[i - 1];
                    auto s1 = std::make_shared<Spring>(p3, p4, stiffness);
                    m_springs.push_back(s1);
                    
                    auto& p5 = layersThickness[layer][i - 1];
                    auto& p6 = layersThickness[layer + 1][i];
                    stiffness = springCrossStiffness[i - 1];
                    auto s2 = std::make_shared<Spring>(p5, p6, stiffness);
                    m_springs.push_back(s2);
                }
            }

            if (m_crossSpringModel)
            {
                // Close the curve
                auto& p1 = layersThickness[layer].back();
                auto& p2 = layersThickness[layer + 1].front();
                float stiffness = m_springs[numPoints - 1]->GetStiffness();
                auto s1 = std::make_shared<Spring>(p1, p2, stiffness);
                m_springs.push_back(s1);

                auto& p3 = layersThickness[layer].front();
                auto& p4 = layersThickness[layer + 1].back();
                stiffness = m_springs[numPoints - 1]->GetStiffness();
                auto s2 = std::make_shared<Spring>(p3, p4, stiffness);
                m_springs.push_back(s2);

                // Add springs between the thickness particles
                for (size_t i = 0; i < numPoints; ++i) {
                    size_t next_i = (i + 1) % numPoints;

                    auto& a = layers[layer][i];
                    auto& b = layers[layer][next_i];
                    auto& a_thick = layersThickness[layer][i];
                    auto& b_thick = layersThickness[layer][next_i];

                    float stiffness = m_springs[i]->GetStiffness();
                    auto s1 = std::make_shared<Spring>(a, b_thick, stiffness);
                    m_springs.push_back(s1);

                    stiffness = m_springs[i]->GetStiffness();
                    auto s2 = std::make_shared<Spring>(b, a_thick, stiffness);
                    m_springs.push_back(s2);

                    auto& c = layers[layer + 1][i];

                    stiffness = springStiffness[i];
                    auto s3 = std::make_shared<Spring>(c, a_thick, stiffness);
                    m_springs.push_back(s3);

                    auto& c_thick = layersThickness[layer + 1][i];
                    stiffness = springStiffness[i];
                    auto s4 = std::make_shared<Spring>(a, c_thick, stiffness);
                    m_springs.push_back(s4);
                    
                }
            }
        }

        // Center particle
        auto centerParticleThickness = std::make_shared<Particle>(centerRing + QVector3D(0, 0, thickness), 1, mass);
        centerParticleThickness->SetFlags(PARTICLE_NO_COLLISION_WITH_US);
        m_particles.push_back(centerParticleThickness);

        // Connect the center to the first layer
        for (auto& p : layersThickness.back()) {
            auto spring = std::make_shared<Spring>(p, centerParticleThickness, 1000.0f); 
            m_springs.push_back(spring);
        }
        auto ringlayers = layersThickness.back();
        for (size_t i = 0; i < ringlayers.size(); ++i) { // Add springs for more rigidity
            auto& p1 = ringlayers[i];
            for (size_t j = 0; j < ringlayers.size(); ++j) {
                if (i == j) continue;
                auto& p2 = ringlayers[j];
                auto spring = std::make_shared<Spring>(p1, p2, 1000.0f);
                m_springs.push_back(spring);
            }
        }
    }

    doneCurrent();

    FillVolumeWithParticle();
}

QVector3D OpenGLWidget::GetPointOntoMesh(const QVector3D& point)
{
    // Project the point onto the mesh
    RayCastResult result;

    Ray ray(point, QVector3D(0, 0, -1));

    float minDistSq = std::numeric_limits<float>::max();
    QVector3D closestPoint = point;

    std::vector<std::shared_ptr<TriangleCollider>> triangles;
    QueryBVH<TriangleCollider>(AABB(point - QVector3D(0.01,0.01,0.01), point + QVector3D(0.01,0.01,0.01)), m_bvhTorsoColliders.get(), triangles);

    for (const auto& triangle : triangles)
    {
        result = RayIntersectsTriangle(ray, triangle);
        if (result.hit)
        {
            float distSq = (result.point - point).lengthSquared();
            if (distSq < minDistSq)
            {
                minDistSq = distSq;
                closestPoint = result.point;
            }
        }
    }

    return closestPoint;

}

void OpenGLWidget::FillVolumeWithParticle()
{
    if (!m_isCurve) return;

    makeCurrent();

    float particleMass = 1.0f;
    float particleRadius = 6.0f;
    float spacing = 0.12f;

    // float particleMass = 5.0f;
    // float particleRadius = 17.0f;
    // float spacing = 0.3f;

    std::unique_ptr<BVHNode<TriangleCollider>> bvh = BuildBVH(m_fillTriangleColliders);

    QVector3D minBound = m_profilePoints[0];
    QVector3D maxBound = m_profilePoints[0];

    // Compute the bounding box of the curve
    for (const auto& pt : m_profilePoints) {
        minBound.setX(std::min(minBound.x(), pt.x()));
        minBound.setY(std::min(minBound.y(), pt.y()));

        maxBound.setX(std::max(maxBound.x(), pt.x()));
        maxBound.setY(std::max(maxBound.y(), pt.y()));
    }

    minBound.setZ(minBound.z() + particleRadius * 0.01f);
    maxBound.setZ(maxBound.z() + (m_curveDepth * m_curveNormal).z() + particleRadius * 0.01f);

    int countX = static_cast<int>((maxBound.x() - minBound.x()) / spacing) + 1;
    int countY = static_cast<int>((maxBound.y() - minBound.y()) / spacing) + 1;
    int countZ = static_cast<int>((maxBound.z() - minBound.z()) / spacing) + 1;

    auto getIndex = [&](int x, int y, int z) {
        return x + y * countX + z * countX * countY;
    };

    std::vector<std::shared_ptr<Particle>> temp(countX * countY * countZ, nullptr);
    
    for (int i = 0; i < countX; ++i) {
        for (int j = 0; j < countY; ++j) {
            for (int k = 0; k < countZ; ++k) {
                QVector3D pos(minBound.x() + i * spacing,
                          minBound.y() + j * spacing,
                          minBound.z() + k * spacing);

                auto p = std::make_shared<Particle>(pos, particleRadius, particleMass);

                std::vector<std::shared_ptr<TriangleCollider>> trianglesClosest;
                // QueryBVH<TriangleCollider>(p->GetAABB(), bvh.get(), trianglesClosest);
                QueryBVH<TriangleCollider>(FromRay(Ray(p->GetPosition(), QVector3D(0, 0, 1)), 0.001f), bvh.get(), trianglesClosest);

                if (IsParticleInsideMesh(p, trianglesClosest)){
                    temp[getIndex(i, j, k)] = p;
                }
            }
        }
    }

    std::vector<std::shared_ptr<Particle>> particlesToAdd;

    for (int i = 0; i < countX; ++i) {
        for (int j = 0; j < countY; ++j) {
            for (int k = 0; k < countZ; ++k) {
                auto p = temp[getIndex(i, j, k)];
                if (!p) continue;

                // X+1
                if (i + 1 < countX) {
                    auto neighbor = temp[getIndex(i + 1, j, k)];
                    if (neighbor) m_springs.push_back(std::make_shared<Spring>(p, neighbor, 200));
                }
                // Y+1
                if (j + 1 < countY) {
                    auto neighbor = temp[getIndex(i, j + 1, k)];
                    if (neighbor) m_springs.push_back(std::make_shared<Spring>(p, neighbor, 200));
                }
                // Z+1
                if (k + 1 < countZ) {
                    auto neighbor = temp[getIndex(i, j, k + 1)];
                    if (neighbor) m_springs.push_back(std::make_shared<Spring>(p, neighbor, 200));
                }

                particlesToAdd.push_back(p);
                m_particles.push_back(p);
            }
        }
    }

    float threshold = spacing * 1.5f;

    for (auto& p : particlesToAdd) {
        std::vector<std::shared_ptr<TriangleCollider>> trianglesClosest;
        QueryBVH<TriangleCollider>(FromRay(Ray(p->GetPosition(), QVector3D(0, 0, 1)), 0.001f), bvh.get(), trianglesClosest);

        float minDist = std::numeric_limits<float>::max();
        std::shared_ptr<TriangleCollider> closestTriangle = nullptr;

        for (auto& tri : trianglesClosest) {
            float d = tri->DistanceTo(p->GetPosition());
            if (d < minDist) {
                minDist = d;
                closestTriangle = tri;
            }
        }

        if (closestTriangle && minDist < threshold) {
            if (!closestTriangle->p0) continue;
            auto spring = std::make_shared<Spring>(p, closestTriangle->p0, 200.0f);
            m_springs.push_back(spring);
        }
    }


    doneCurrent();
}*/

/*
void PhysicsSystem::Update(float deltaTime)
{
    // Apply forces on the object
    for (size_t i = 0, size = bodies.size(); i < size; ++i) {
        bodies[i]->ApplyForces();
        bodies[i]->Update(deltaTime);
    }

    // Apply spring forces
    for (size_t i = 0, size = springs.size(); i < size; ++i) {
        for (int step = 0, substeps = 5; step < substeps; ++step) {
            springs[i]->ApplyForce(deltaTime / substeps);
        }
        // springs[i]->ApplyForce(deltaTime);
    }

    // Update BVH for collision detection
    bvhRigidbodies = BuildBVH(constraints);
    bvhTriangleColliders = BuildBVH(triangleColliders);

    // Solve constraints
    const int constraintIterations = 4;
    for (int iter = 0; iter < constraintIterations; ++iter) {
        for (auto& constraint : constraints) {
            std::vector<std::shared_ptr<Rigidbody>> nearbyRigdibodies;
            std::vector<std::shared_ptr<TriangleCollider>> nearbyTriangles;

            QueryBVH<Rigidbody>(constraint->GetAABB(), bvhRigidbodies.get(), nearbyRigdibodies);
            constraint->SolveConstraints(nearbyRigdibodies);

            QueryBVH<TriangleCollider>(constraint->GetAABB(), bvhTriangleColliders.get(), nearbyTriangles);
            constraint->SolveConstraints(nearbyTriangles);
        }
        
    }
}
*/